import java.time.LocalDate;

public class Main {
    public static boolean checkIsLeap(int year) {
        return (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0));
    }

    public static  void printLeapYear(int year) {
        if (checkIsLeap(year)) {
            System.out.println(year + " год  -    високосный ");
            return ;
        }
            System.out.println(year + " год  - НЕ високосный ");
    }

    public static String chechVersionOS(boolean OS, int year, int checkYear) {
        String light = " " ;
        if (year < checkYear) { light = "облегченную ";
        }
        if (OS) {
           return "Установите " + light + "версию приложения для Android по ссылке ";
        }
        return "Установите " + light + "версию приложения для iOS по ссылке";
    }

    public static int calcTimeDevivery(int distance) {
        return (int) (((distance - 20) / 40) + 1);
    }

    public static void main(String[] args) {

//        ###   Задание 1
//
//        Реализуйте метод, который получает в качестве параметра год, а затем проверяет, является ли он високосным, и выводит результат в консоль. 
//
//        *Эту проверку вы уже реализовывали в задании по условным операторам.*
//
//        Теперь проверку нужно обернуть в метод и использовать год, который приходит в виде параметра.
//
//        Результат программы выведите в консоль. Если год високосный, то должно быть выведено “*номер года —* високосный год”. Если год не високосный, то, соответственно: “*номер года —* не **високосный год”.
//        System.out.println("Hello world!");
        for (int i = 1184; i <= 1614; i++  ) {
            printLeapYear(i);
        }


//        ### Задание 2
//
//        Вспомним задание 2 по условным операторам, где нам необходимо было предложить пользователю облегченную версию приложения.
//
//        - Текст прошлого задания
//
//        К нам пришли коллеги и сообщили, что нам нужно знать не только операционную систему телефона, но и год его создания: от этого зависит, подойдет ли приложение для телефона или оно просто не установится.
//
//        Если телефон произведен с 2015 по нынешний год, то приложение будет работать корректно.
//
//        Если телефон произведен ранее 2015 года, то клиенту нужно посоветовать установить облегченную версию приложения.
//
//                Ваша задача: написать программу, которая выдает соответствующее сообщение клиенту при наличии двух условий — операционной системы телефона (iOS или Android) и года производства.
//
//                Если год выпуска ранее 2015 года, то к сообщению об установке нужно добавить информацию об облегченной версии.
//
//        Например, для iOS оно будет звучать так:
//
//    «Установите облегченную версию приложения для iOS по ссылке».
//
//        А для Android так:
//
//    «Установите облегченную версию приложения для Android по ссылке».

//        При этом для пользователей с телефоном с 2015 года выпуска нужно вывести обычное предложение об установке приложения.
//
//                Для обозначения года создания используйте переменную clientDeviceYear, где необходимо указать 2015 год.
//
//                **Важно**: вложенность больше двух этажей не допускается (условный оператор внутри условного оператора).
//
//
//        Напишите метод, куда подаются два параметра: тип операционной системы (ОС) ( 0 — iOS или 1 — Android ) и год выпуска устройства.
//
//        Если устройство старше текущего года, предложите ему установить lite-версию (облегченную версию).
//
//                Текущий год можно получить таким способом:
//
//```java
//        int currentYear = LocalDate.now().getYear();
//```
//
//        Или самим задать значение вручную, введя в переменную числовое значение.
//
//        В результате программа должна выводить в консоль в зависимости от исходных данных, какую версию приложения (обычную или lite) и для какой ОС (Android или iOS) нужно установить пользователю.

        int currentYear = LocalDate.now().getYear();

        for (int i = 2014; i <= currentYear + 3  ; i++  ) {
            System.out.println("Год выпуска телефона - " + i + ", рекомендация : "  +  chechVersionOS( (i % 2 == 0 ) , i, currentYear ));
        }

//        Задание 3
//        Возвращаемся к любимой многими задаче на расчет дней доставки банковской карты от банка.
//
//                - Текст прошлого задания
//
//        Вернемся к делам банковским. У нас хороший банк, поэтому для наших клиентов мы организуем доставку банковских карт на дом с четкой датой доставки. Чтобы известить клиента о том, когда будет доставлена его карта, нам нужно знать расстояние от нашего офиса до адреса доставки.
//
//                Правила доставки такие:
//
//        Доставка в пределах 20 км занимает сутки.
//
//                Доставка в пределах от 20 км до 60 км добавляет еще один день доставки.
//
//        Доставка в пределах 60 км до 100 км добавляет еще одни сутки.
//
//                То есть с каждым следующим интервалом доставки срок увеличивается на 1 день.
//
//                Напишите программу, которая выдает сообщение в консоль:
//
//        "Потребуется дней: " + срок доставки
//
//        Объявите целочисленную переменную deliveryDistance = 95, которая содержит дистанцию до клиента.
//
//
//        Наша задача — доработать код, а именно написать метод, который на вход принимает дистанцию и возвращает итоговое количество дней доставки.

        for (int deliveryDistance = 18 ; deliveryDistance  <= 180 ; deliveryDistance += 18  ) {
            System.out.println("Дистанция " + deliveryDistance + ". Для доставки потребуется дней: " +  calcTimeDevivery(deliveryDistance));
        }

    }
}
